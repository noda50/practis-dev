#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

require 'json'

require 'practis'
require 'practis/parameter_parser'
require 'practis/parameter_scheduler'

module Practis

  ##############################################################################
  # relationship of Parameter, ParameterSet, Variable and VariableSet class.
  #
  # Variable va has {1, 2, ..,}    => Parameter pa1: 1, Parameter pa2: 2, ...
  # Variable vb has {8, 16, ..,}   => Parameter pb1: 8, Parameter pb2: 16, ...
  # Variable vc has {12, 22, ..,}  => Parameter pc1: 12, Parameter pc2: 22, ...
  # ...
  # Variable vn has {993, 994, ..,} => Parameter pn1: 993, Parameter pn2: 994,
  # ...
  # VariableSet vs has {va, vb, vc, ..., vn}
  # ParameterSet ps1 has {pa1, pb1, pc1, ..., pn1}
  ##############################################################################

  #=== Parameter generated by ParameterParser
  class Parameter

    include Practis

    attr_reader :name     # The name of the variable.
    attr_reader :type     # The type of the variable.
    attr_reader :value    # The value of this parameter

    #=== initialize method.
    #name :: a parameter name.
    #type :: a parameter type.
    #value :: a value of the parameter.
    def initialize(name, type, value)
      @name = chk_arg(String, name)
      @type = string_to_type(chk_arg(String, type))
      # Check whether the value type matches with @type?
      @value = chk_arg(@type, value, true)
    end
  end


  #=== Parameter set consists of Parameter objects
  class ParameterSet

    include Practis

    attr_accessor :parameter_set    # An array object of Parameter class.
    attr_accessor :state            # The state of the parameter set.
    attr_reader :uid                # An unique identifier

    #=== initialize method.
    #uid :: an unique identifier of the parameter set.
    #parameter_set :: an initial parameter set if specified.
    def initialize(uid = nil, parameter_set = nil)
      uid ||= Practis::VariableSet.allocate_new_id
      @uid = chk_arg(Integer, uid)
      @parameter_set = chk_arg(Array, parameter_set, true)
      unless @parameter_set.nil?
        @parameter_set.each do |parameter|
          if parameter.class != Parameter
            @parameter_set = []
            warn("parameter set has to be Parameter class.")
            break
          end
        end
      end
      @state = PARAMETER_STATE_READY
    end
  end

  #=== Variable that generates Parameters from Pattern.
  class Variable

    include Practis

    attr_reader :name     # The name of the variable.
    attr_reader :type     # The type of the variable.
    # The value pattern of this variable. The pattern has to be json string
    # object that is generated by ParameterParser.
    attr_reader :pattern
    attr_accessor :finished   # finished parameters.
    attr_accessor :available  # not finished parameters.
    attr_reader :parameters   # all parameters (should not be modified)

    #=== initialize method.
    #name :: a variable name.
    #type :: a variable type.
    #pattern :: a Pattern class object.
    def initialize(name, type, pattern)
      @name = chk_arg(String, name)
      @type = chk_arg(String, type)
      @type = string_to_type(@type)
      @pattern = chk_arg(String, pattern)
      @finished = []
      @available = []
      @parameters = []
      pattern_generate
    end

    #=== generate variables with the pattern.
    def pattern_generate
      available.clear
      hash = JSON.parse(pattern, :symbolize_names => true)
      hash.each do |p|
        case p[:type]
        when INCLUDE_RANGE
          get_range_values(p).each { |value|
            available.push(value) unless available.include?(value) }
        when EXCLUDE_RANGE
          get_range_values(p).each { |value|
            available.delete(value) if available.include?(value) }
        when INCLUDE_LIST
          p[:list].each { |list|
            available.push(list) unless available.include?(list) }
        when EXCLUDE_LIST
          p[:list].each { |list|
            available.delete(list) if available.include?(list) }
        end
      end
      available.sort!
      available.each { |parameter| parameters.push(parameter) }
    end

    #=== generate an array of range value.
    def get_range_values(json)
      range_values = []
      startval = chk_arg(type, json[:start])
      endval = chk_arg(type, json[:end])
      stepval = chk_arg(type, json[:step])
      if startval.nil? || endval.nil? || stepval.nil?
        warn("invalid range pattern. start val: #{startval}, end val: " +
             "#{endval}, step val: #{stepval}")
        return range_values
      end
      startval, endval = endval, startval if startval > endval
      stepval *= -1 if stepval < 0
      while startval <= endval
        range_values.push(startval) unless range_values.include?(startval)
        if startval.kind_of?(Float)
          startval = (BigDecimal(startval.to_s) + BigDecimal(stepval.to_s)).to_f
        else
          startval += stepval
        end
      end
      return range_values
    end

    #=== get a next available parameter.
    #returned_value :: a next available parameter.
    def get_next
      # If all pattern is allocated.
      return nil if self.length <= 0
      finished.push(retval = available.shift)
      return retval
    end

    #=== get a n-th parameter.
    def get_n(n)
      if self.length <= n || n < 0
        warn("invalid index: #{n}, for #{self.length}-length variables.")
        return nil
      end
      return parameters[n]
    end

    #=== Available parameter length.
    def length
      return available.length
    end
  end

  #=== Variable set.
  class VariableSet

    include Practis

    # Unique IDs pool
    @@id_pool = []

    # An array of Variable.
    attr_reader :variable_set
    # An approximation method for variables.
    attr_accessor :approximation
    # A scheduler of parameter allocation.
    attr_reader :scheduler

    #=== initialize method.
    #variable_set :: an array of Variable objects.
    #scheduler :: a class name of the scheculer.
    def initialize(variable_set, scheduler="RoundrobinScheduler")
      @variable_set = chk_arg(Array, variable_set)
      @scheduler = Practis::ParameterScheduler.new(variable_set, scheduler)
    end

    #=== get a next available parameter set.
    def get_next
      return nil if (parameter_array =
                     chk_arg(Array, scheduler.get_parameter_set, true)).nil?
      parameter_set = []
      variable_set.length.times { |i| parameter_set
        .push(Parameter.new(variable_set[i].name,
                            type_to_string(variable_set[i].type),
                            parameter_array[i])) }
      return ParameterSet.new(Practis::VariableSet.allocate_new_id,
                              parameter_set)
    end

    #=== get a number of available variable set.
    def get_available
      return scheduler.get_available
    end

    #=== get a total number of variable set.
    def get_total
      return scheduler.get_total
    end

    #=== Allocate a new id for a parameter set.
    #ID must be unique, this method allocate a new ID for a parameter set.
    #id :: if you want to specify a static id, use this arg.
    #returned_value :: an allocated new id.
    def self.allocate_new_id(id=nil)
      new_id = -1
      if id.nil?
        count = 0
        max_parameter = Practis::PARAMETER_ID_DURATION
        while true
          new_id = rand(max_parameter).to_i
          (@@id_pool.push(new_id); break) unless @@id_pool.include?(new_id)
          count += 1
          max_parameter += Practis::PARAMETER_ID_DURATION \
            if count > max_parameter
        end
      else
        new_id = id
        (error("specified ID already exist!"); return nil) \
          if @@id_pool.include?(new_id)
        @@id_pool.push(new_id)
      end
      return new_id
    end
  end
end
