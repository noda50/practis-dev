#!/usr/bin/env ruby
# -*- coding: utf-8 -*-

require 'json'

require 'practis'
require 'practis/parameter_parser'
require 'practis/parameter_scheduler'

module Practis

  #=== an instance of Parameter Value class
  class Parameter

    include Practis

    # a name of the parameter.
    attr_reader :name
    # a type of the parameter.
    attr_reader :type
    # a value of this parameter
    attr_reader :value

    #=== initialize method.
    #name :: a parameter name.
    #type :: a parameter type.
    #value :: a value of the parameter.
    def initialize(name, type, value)
      @name = chk_arg(String, name)
      @type = string_to_type(chk_arg(String, type))
      @value = chk_arg(@type, value, true)
    end
  end


  #=== a set of Parameter instance
  class ParameterSet

    include Practis

    # An array object of Parameter class.
    attr_accessor :parameter_set
    # The state of the parameter set.
    attr_accessor :state
    # An unique identifier
    attr_reader :uid

    #=== initialize method.
    #uid :: an unique identifier of the parameter set.
    #parameter_set :: an initial parameter set if specified.
    def initialize(uid = nil, parameter_set = nil)
      uid ||= Practis::ParamDefSet.allocate_new_id
      @uid = chk_arg(Integer, uid)
      @parameter_set = chk_arg(Array, parameter_set, true)
      @parameter_set.each { |p| chk_arg(Parameter, p) }
      @state = PARAMETER_STATE_READY
    end
  end

  #=== Definition of Parameter that generates Parameters from Pattern.
  class ParamDef

    include Practis

    # The name of the parameter.
    attr_reader :name
    # The type of the parameter.
    attr_reader :type
    # The value pattern of this parameter. The pattern has to be json string
    # object that is generated by ParameterParser.
    attr_reader :pattern
    # all parameter values (should not be modified)
    attr_reader :values

    #=== initialize method.
    #name :: a parameter name.
    #type :: a parameter type.
    #pattern :: a Pattern class object.
    def initialize(name, type, pattern)
      @name = chk_arg(String, name)
      @type = chk_arg(String, type)
      @type = string_to_type(@type)
      @pattern = chk_arg(String, pattern)
      @values = []
      pattern_generate
    end

    #=== generate parameter values with the pattern.
    def pattern_generate
      @values.clear
      hash = JSON.parse(pattern, :symbolize_names => true)
      hash.each do |p|
        case p[:type]
        when INCLUDE_RANGE
          get_range_values(p).each { |value|
            @values.push(value) unless @values.include?(value) }
        when EXCLUDE_RANGE
          get_range_values(p).each { |value|
            @values.delete(value) if @values.include?(value) }
        when INCLUDE_LIST
          p[:list].each { |list|
            @values.push(list) unless @values.include?(list) }
        when EXCLUDE_LIST
          p[:list].each { |list|
            @values.delete(list) if @values.include?(list) }
        end
      end
    end

    #=== generate an array of range value.
    def get_range_values(json)
      range_values = []
      startval = chk_arg(type, json[:start])
      endval = chk_arg(type, json[:end])
      stepval = chk_arg(type, json[:step])
      if startval.nil? || endval.nil? || stepval.nil?
        warn("invalid range pattern. start val: #{startval}, end val: " +
             "#{endval}, step val: #{stepval}")
        return range_values
      end
      startval, endval = endval, startval if startval > endval
      stepval *= -1 if stepval < 0
      while startval <= endval
        range_values.push(startval) unless range_values.include?(startval)
        if startval.kind_of?(Float)
          startval = (BigDecimal(startval.to_s) + BigDecimal(stepval.to_s)).to_f
        else
          startval += stepval
        end
      end
      return range_values
    end

    #=== get a n-th value.
    def get_n(n)
      if @values.length <= n || n < 0
        warn("invalid index: #{n}, for #{@values.length}-length values.")
        return nil
      end
      return @values[n]
    end

    #=== Available parameter length.
    def length
      return @values.length
    end

    ## [2013/09/12 H.Matsushima] for design of experiment
    # === 
    def add_value(val)
      @values += val
    end
  end

  #=== ParamDef set.
  class ParamDefSet

    include Practis

    # Unique IDs pool
    @@id_pool = []  ## [2013/09/07 I.Noda] not used

    # An array of ParamDefs.
    attr_reader :paramDefs
    # An approximation method for Parameter.
    attr_accessor :approximation
    # A scheduler of parameter allocation.
    attr_reader :scheduler

    #=== initialize method.
    #paramDefs :: an array of ParamDef objects.
    #scheduler :: a class name of the scheduler.
    def initialize(paramDefs, scheduler = "RoundrobinScheduler")
      @paramDefs = chk_arg(Array, paramDefs)
      @scheduler = Practis::ParameterScheduler.new(@paramDefs, scheduler)
    end

    #=== get a next available parameter value set.
    def get_next(newId)
      return nil if (parameter_array =
                     chk_arg(Array, @scheduler.get_parameter_set(newId), true)).nil?
      parameter_set = []
      @paramDefs.length.times { |i| parameter_set
        .push(Parameter.new(@paramDefs[i].name,
                            type_to_string(@paramDefs[i].type),
                            parameter_array[i])) }
      ##[2013/09/07 I.Noda] now, id is given. (taken from database by caller)
      #newId = Practis::ParamDefSet.allocate_new_id ;
      return ParameterSet.new(newId, parameter_set)
    end

    #=== get a number of available paramValue set.
    def get_available
      return @scheduler.get_available
    end

    #=== get a total number of paramValue set.
    def get_total
      return @scheduler.get_total
    end

    ## [2013/09/12 H.Matsushima] add for design of experiment
    #=== use by design of experiment
    def add_paramDefs(name, paramDefs, old_area, extend_poit)
      @paramDefs += chk_arg(Array, paramDefs)
      new_params = []
      new_params.push({:name => name, :paramDefs => paramDefs})
      @scheduler.orthogonal_table.extend_table(old_area, extend_poit, new_params)
    end

    ## [2013/09/07 I.Noda] not used anymore
    #=== Allocate a new id for a parameter set.
    #ID must be unique, this method allocate a new ID for a parameter set.
    #id :: if you want to specify a static id, use this arg.
    #returned_value :: an allocated new id.
    def self.allocate_new_id(id=nil)
      new_id = -1
      if id.nil?
        count = 0
        max_parameter = Practis::PARAMETER_ID_DURATION
        while true
          new_id = rand(max_parameter).to_i
          (@@id_pool.push(new_id); break) unless @@id_pool.include?(new_id)
          count += 1
          max_parameter += Practis::PARAMETER_ID_DURATION \
            if count > max_parameter
        end
      else
        new_id = id
        (error("specified ID already exist!"); return nil) \
          if @@id_pool.include?(new_id)
        @@id_pool.push(new_id)
      end
      return new_id
    end
  end
end
